# continuous_mode.py - Criar modo de escuta cont√≠nua inteligente
import os

print("üîß Criando modo de escuta cont√≠nua inteligente...")

# 1. Atualizar speech_to_text.py para escuta cont√≠nua
stt_code = '''# core/speech_to_text.py
import asyncio
import logging
import speech_recognition as sr
import threading
import time
from typing import Optional, Callable
from config.settings import VoiceConfig

class SpeechToText:
    """Classe para reconhecimento de voz com escuta cont√≠nua"""
    
    def __init__(self, config: VoiceConfig):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Inicializar reconhecedor
        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone()
        
        # Estado da escuta cont√≠nua
        self.is_listening_continuously = False
        self.continuous_thread = None
        self.callback_function = None
        
        # Configurar microfone
        self.setup_microphone()
    
    def setup_microphone(self):
        """Configura o microfone"""
        try:
            with self.microphone as source:
                self.logger.info("Calibrando microfone...")
                self.recognizer.adjust_for_ambient_noise(source, duration=1)
                # Ajustar para escuta cont√≠nua
                self.recognizer.energy_threshold = 4000
                self.recognizer.dynamic_energy_threshold = True
                self.recognizer.pause_threshold = 1.0
                self.logger.info("Microfone calibrado para escuta cont√≠nua!")
        except Exception as e:
            self.logger.error(f"Erro ao configurar microfone: {e}")
    
    async def listen(self, timeout: int = 5) -> Optional[str]:
        """Escuta uma √∫nica vez (modo manual)"""
        try:
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(None, self._listen_once, timeout)
        except Exception as e:
            self.logger.error(f"Erro no reconhecimento de voz: {e}")
            return None
    
    def _listen_once(self, timeout: int) -> Optional[str]:
        """M√©todo para escuta √∫nica"""
        try:
            print("üé§ Escutando... (fale agora)")
            
            with self.microphone as source:
                audio = self.recognizer.listen(source, timeout=timeout, phrase_time_limit=10)
            
            print("üîÑ Processando...")
            
            try:
                text = self.recognizer.recognize_google(
                    audio, 
                    language=self.config.recognition_language
                )
                return text.strip()
            except sr.UnknownValueError:
                print("‚ùå N√£o consegui entender")
                return None
            except sr.RequestError as e:
                print("‚ùå Erro no servi√ßo de reconhecimento")
                return None
                
        except sr.WaitTimeoutError:
            print("‚è∞ Timeout")
            return None
        except Exception as e:
            print(f"‚ùå Erro: {e}")
            return None
    
    def start_continuous_listening(self, callback: Callable[[str], None]):
        """Inicia escuta cont√≠nua em background"""
        if self.is_listening_continuously:
            return
        
        self.callback_function = callback
        self.is_listening_continuously = True
        
        # Iniciar thread de escuta cont√≠nua
        self.continuous_thread = threading.Thread(
            target=self._continuous_listen_worker,
            daemon=True
        )
        self.continuous_thread.start()
        
        print("üëÇ MODO ESCUTA CONT√çNUA ATIVADO")
        print("üí° Agora estou sempre escutando... fale naturalmente!")
    
    def stop_continuous_listening(self):
        """Para escuta cont√≠nua"""
        self.is_listening_continuously = False
        if self.continuous_thread:
            self.continuous_thread.join(timeout=2)
        print("üîá Escuta cont√≠nua desativada")
    
    def _continuous_listen_worker(self):
        """Worker thread para escuta cont√≠nua"""
        self.logger.info("Iniciando escuta cont√≠nua...")
        
        while self.is_listening_continuously:
            try:
                with self.microphone as source:
                    # Escutar com timeout curto para n√£o bloquear
                    audio = self.recognizer.listen(source, timeout=1, phrase_time_limit=8)
                
                # Processar √°udio em background
                try:
                    text = self.recognizer.recognize_google(
                        audio, 
                        language=self.config.recognition_language
                    )
                    
                    if text and text.strip():
                        # Chamar callback com o texto reconhecido
                        if self.callback_function:
                            self.callback_function(text.strip())
                            
                except sr.UnknownValueError:
                    # Ignorar silenciosamente quando n√£o entender
                    pass
                except sr.RequestError:
                    # Pausar um pouco se houver erro de rede
                    time.sleep(2)
                    
            except sr.WaitTimeoutError:
                # Timeout normal, continuar escutando
                pass
            except Exception as e:
                self.logger.error(f"Erro na escuta cont√≠nua: {e}")
                time.sleep(1)
        
        self.logger.info("Escuta cont√≠nua finalizada")
'''

# 2. Criar sistema de an√°lise inteligente de contexto
context_analyzer_code = '''# core/context_analyzer.py
import re
import logging
from typing import List, Dict, Tuple
from datetime import datetime

class ContextAnalyzer:
    """Analisa contexto da fala para decidir quando a IA deve responder"""
    
    def __init__(self, agent_name: str = "ARIA"):
        self.agent_name = agent_name.lower()
        self.logger = logging.getLogger(__name__)
        
        # Padr√µes que indicam que √© direcionado √† IA
        self.direct_patterns = [
            # Men√ß√µes diretas
            rf"\\b{self.agent_name}\\b",
            r"\\baria\\b",
            r"\\bassistente\\b",
            r"\\bia\\b",
            r"\\brob√¥\\b",
            r"\\bbot\\b",
            
            # Palavras de comando
            r"\\b(ei|hey|ol√°|oi)\\s+(aria|assistente|ia)\\b",
            r"\\b(me ajuda|ajude|responda|diga|fala)\\b",
            r"\\b(voc√™ pode|consegue|sabe)\\b",
            r"\\bqual.{0,20}(√©|meu|seu|nome|hora|dia)\\b",
            r"\\bcomo.{0,20}(voc√™|est√°|vai|fazer)\\b",
            r"\\bo que.{0,20}(voc√™|√©|faz|acha)\\b",
        ]
        
        # Padr√µes que sugerem men√ß√£o indireta mas relevante
        self.indirect_patterns = [
            # Falando SOBRE a IA
            rf"\\b(essa|esta|a)\\s+{self.agent_name}\\b",
            r"\\b(essa|esta|a)\\s+(ia|assistente)\\b",
            r"\\bfalando.{0,10}(da|sobre).{0,10}(ia|assistente|aria)\\b",
            
            # Opini√µes sobre IA
            r"\\b(ia|assistente|aria).{0,20}(√©|est√°|foi|fica).{0,20}(ruim|boa|legal|chata|inteligente|burra)\\b",
            r"\\b(n√£o gosto|odeio|amo|gosto).{0,20}(da|dessa).{0,20}(ia|assistente|aria)\\b",
            r"\\b(ia|assistente|aria).{0,20}(n√£o|nunca).{0,20}(funciona|entende|responde|ajuda)\\b",
            
            # Compara√ß√µes
            r"\\b(melhor|pior).{0,20}que.{0,20}(ia|assistente|aria)\\b",
            r"\\b(ia|assistente|aria).{0,20}(melhor|pior).{0,20}que\\b",
        ]
        
        # Padr√µes que sugerem que N√ÉO √© para a IA
        self.ignore_patterns = [
            r"\\b(n√£o|nem).{0,10}(fala|responde|liga).{0,10}(aria|ia|assistente)\\b",
            r"\\b(cala|sil√™ncio|quieta).{0,10}(aria|ia|assistente)\\b",
            r"\\bestou falando com\\b",
            r"\\bn√£o √© com voc√™\\b",
        ]
        
    def should_respond(self, text: str, user_name: str = "") -> Tuple[bool, str, float]:
        """
        Analisa se a IA deve responder
        
        Returns:
            (should_respond: bool, reason: str, confidence: float)
        """
        text_lower = text.lower()
        
        # 1. Verificar padr√µes de ignorar (prioridade m√°xima)
        for pattern in self.ignore_patterns:
            if re.search(pattern, text_lower):
                return False, "Usu√°rio pediu para n√£o responder", 0.0
        
        # 2. Verificar men√ß√µes diretas (alta prioridade)
        for pattern in self.direct_patterns:
            if re.search(pattern, text_lower):
                confidence = 0.9
                # Aumentar confian√ßa se mencionar nome do usu√°rio
                if user_name and user_name.lower() in text_lower:
                    confidence = 0.95
                return True, "Men√ß√£o direta detectada", confidence
        
        # 3. Verificar men√ß√µes indiretas (m√©dia prioridade)
        for pattern in self.indirect_patterns:
            if re.search(pattern, text_lower):
                return True, "Men√ß√£o indireta detectada", 0.7
        
        # 4. Verificar perguntas gerais que podem ser para a IA
        question_patterns = [
            r"\\b(que horas|que dia|que data)\\b",
            r"\\b(como est√°|como vai|tudo bem)\\b",
            r"\\b(voc√™|voc√™s).{0,20}(est√°|est√£o|vai|v√£o)\\b",
        ]
        
        for pattern in question_patterns:
            if re.search(pattern, text_lower):
                # S√≥ responder se n√£o houver outras pessoas sendo mencionadas
                if not re.search(r"\\b(ele|ela|jo√£o|maria|pedro|ana|fulano)\\b", text_lower):
                    return True, "Pergunta geral possivelmente direcionada", 0.5
        
        # 5. Detectar se est√£o falando mal da IA (para defesa)
        negative_patterns = [
            r"\\b(ia|assistente|aria).{0,30}(ruim|horr√≠vel|p√©ssima|in√∫til|burra)\\b",
            r"\\b(odeio|detesto).{0,20}(ia|assistente|aria)\\b",
            r"\\b(ia|assistente|aria).{0,20}n√£o.{0,20}(serve|funciona|presta)\\b",
        ]
        
        for pattern in negative_patterns:
            if re.search(pattern, text_lower):
                return True, "Coment√°rio negativo sobre a IA - defesa necess√°ria", 0.8
        
        return False, "N√£o parece ser direcionado √† IA", 0.0
    
    def analyze_emotional_context(self, text: str) -> Dict[str, float]:
        """Analisa contexto emocional da fala"""
        text_lower = text.lower()
        
        emotions = {
            "feliz": 0.0,
            "triste": 0.0,
            "raiva": 0.0,
            "neutro": 0.0,
            "curioso": 0.0
        }
        
        # Padr√µes de felicidade
        happy_words = ["feliz", "alegre", "√≥timo", "excelente", "adorei", "amei", "legal", "bom"]
        emotions["feliz"] = sum(1 for word in happy_words if word in text_lower) / len(text_lower.split()) * 10
        
        # Padr√µes de tristeza
        sad_words = ["triste", "chateado", "ruim", "p√©ssimo", "horr√≠vel", "mal"]
        emotions["triste"] = sum(1 for word in sad_words if word in text_lower) / len(text_lower.split()) * 10
        
        # Padr√µes de raiva
        angry_words = ["raiva", "√≥dio", "irritado", "furioso", "maldita", "droga"]
        emotions["raiva"] = sum(1 for word in angry_words if word in text_lower) / len(text_lower.split()) * 10
        
        # Padr√µes de curiosidade
        curious_words = ["como", "por que", "quando", "onde", "qual", "?"]
        emotions["curioso"] = sum(1 for word in curious_words if word in text_lower) / len(text_lower.split()) * 5
        
        # Se nenhuma emo√ß√£o forte, √© neutro
        if max(emotions.values()) < 0.1:
            emotions["neutro"] = 1.0
        
        return emotions
'''

# 3. Atualizar agent.py com modo cont√≠nuo
agent_code = '''# core/agent.py
import asyncio
import logging
import signal
import sys
from datetime import datetime
from typing import Optional, Dict, Any

from core.speech_to_text import SpeechToText
from core.text_to_speech import TextToSpeech
from core.conversation import ConversationManager
from core.context_analyzer import ContextAnalyzer
from memory.user_profile import UserProfile
from memory.database import DatabaseManager
from models.local_llm import LocalLLM
from config.settings import AgentConfig

class AIAgent:
    """Classe principal do agente de IA com escuta cont√≠nua inteligente"""
    
    def __init__(self, config: AgentConfig):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Componentes principais
        self.stt: Optional[SpeechToText] = None
        self.tts: Optional[TextToSpeech] = None
        self.llm: Optional[LocalLLM] = None
        self.conversation_manager: Optional[ConversationManager] = None
        self.user_profile: Optional[UserProfile] = None
        self.database: Optional[DatabaseManager] = None
        self.context_analyzer: Optional[ContextAnalyzer] = None
        
        # Estado do agente
        self.is_listening = False
        self.is_speaking = False
        self.is_running = False
        self.continuous_mode = False
        
    async def initialize(self):
        """Inicializa todos os componentes do agente"""
        self.logger.info("Inicializando componentes do agente...")
        
        try:
            # Inicializar banco de dados
            self.database = DatabaseManager(self.config.database)
            await self.database.initialize()
            
            # Inicializar perfil do usu√°rio
            self.user_profile = UserProfile(self.database)
            await self.user_profile.load_profile()
            
            # Inicializar modelo de IA
            self.llm = LocalLLM(self.config.model)
            await self.llm.initialize()
            
            # Inicializar componentes de voz
            self.stt = SpeechToText(self.config.voice)
            self.tts = TextToSpeech(self.config.voice)
            
            # Inicializar analisador de contexto
            self.context_analyzer = ContextAnalyzer(self.config.name)
            
            # Inicializar gerenciador de conversas
            self.conversation_manager = ConversationManager(
                self.database, 
                self.user_profile,
                self.config
            )
            
            self.logger.info("Todos os componentes inicializados com sucesso!")
            
        except Exception as e:
            self.logger.error(f"Erro ao inicializar agente: {e}")
            raise
    
    async def run(self):
        """Loop principal do agente"""
        self.is_running = True
        
        # Sauda√ß√£o inicial
        user_name = self.user_profile.get_user_name()
        if user_name == "usu√°rio":
            greeting = "Ol√°! Sou a ARIA. Qual √© o seu nome?"
        else:
            greeting = f"Ol√° {user_name}! Sou a ARIA, sua assistente pessoal."
        
        print(f"\\nü§ñ ARIA: {greeting}")
        
        print("\\n" + "="*60)
        print("ü§ñ MODOS DISPON√çVEIS:")
        print("‚å®Ô∏è  'texto' = modo texto normal")
        print("üé§ 'voz' = falar uma vez")  
        print("üëÇ 'continuo' = ESCUTA CONT√çNUA INTELIGENTE")
        print("‚ùå 'sair' = encerrar")
        print("=" * 60 + "\\n")
        
        try:
            while self.is_running:
                if not self.continuous_mode:
                    user_input = await self.get_user_input()
                    
                    if user_input:
                        if self.check_exit_command(user_input):
                            break
                        
                        if user_input.lower() == "continuo":
                            await self.start_continuous_mode()
                            continue
                        elif user_input.lower() == "voz":
                            voice_input = await self.listen_once()
                            if voice_input:
                                user_input = voice_input
                            else:
                                continue
                        elif user_input.lower().startswith("nome "):
                            name = user_input[5:].strip()
                            await self.set_user_name(name)
                            continue
                        
                        response = await self.process_input(user_input)
                        if response:
                            await self.speak(response)
                else:
                    # Modo cont√≠nuo ativo - aguardar
                    await asyncio.sleep(0.5)
                
        except KeyboardInterrupt:
            print("\\n‚ö†Ô∏è Encerrando...")
        finally:
            await self.shutdown()
    
    async def start_continuous_mode(self):
        """Inicia modo de escuta cont√≠nua"""
        self.continuous_mode = True
        print("\\nüëÇ MODO CONT√çNUO ATIVADO!")
        print("üí° Agora estou sempre escutando... fale naturalmente!")
        print("üì¢ Me mencione por 'ARIA' ou fale sobre mim que eu respondo")
        print("üîá Digite 'parar' para desativar")
        print("\\n" + "="*50)
        
        # Iniciar escuta cont√≠nua
        self.stt.start_continuous_listening(self.on_continuous_speech)
        
        # Loop para comandos de texto enquanto escuta
        while self.continuous_mode and self.is_running:
            try:
                # Aguardar comando de texto (n√£o bloqueante)
                print("\\nüí¨ [Comando ou 'parar' para sair do modo cont√≠nuo]:")
                
                loop = asyncio.get_event_loop()
                user_text = await asyncio.wait_for(
                    loop.run_in_executor(None, input, ">>> "),
                    timeout=1.0
                )
                
                if user_text.strip().lower() == "parar":
                    self.stop_continuous_mode()
                    break
                elif user_text.strip().lower() == "sair":
                    self.is_running = False
                    break
                elif user_text.strip():
                    response = await self.process_input(user_text.strip())
                    if response:
                        await self.speak(response)
                        
            except asyncio.TimeoutError:
                # Timeout normal, continuar escutando
                continue
            except Exception as e:
                self.logger.error(f"Erro no modo cont√≠nuo: {e}")
                break
    
    def stop_continuous_mode(self):
        """Para modo cont√≠nuo"""
        self.continuous_mode = False
        self.stt.stop_continuous_listening()
        print("\\nüîá Modo cont√≠nuo desativado")
        print("üí¨ Voltando ao modo normal...")
    
    def on_continuous_speech(self, text: str):
        """Callback chamado quando detecta fala no modo cont√≠nuo"""
        try:
            print(f"\\nüëÇ Ouvi: \"{text}\"")
            
            # Analisar se deve responder
            should_respond, reason, confidence = self.context_analyzer.should_respond(
                text, 
                self.user_profile.get_user_name()
            )
            
            print(f"üß† An√°lise: {reason} (confian√ßa: {confidence:.1f})")
            
            if should_respond and confidence > 0.4:
                print("üéØ Vou responder!")
                
                # Processar resposta em background
                asyncio.create_task(self.handle_continuous_response(text, reason, confidence))
            else:
                print("ü§ê N√£o √© comigo, continuando a escutar...")
                
        except Exception as e:
            self.logger.error(f"Erro no processamento cont√≠nuo: {e}")
    
    async def handle_continuous_response(self, text: str, reason: str, confidence: float):
        """Manipula resposta no modo cont√≠nuo"""
        try:
            # Salvar na conversa
            await self.conversation_manager.add_message("user", text)
            
            # Gerar resposta baseada no contexto
            response = await self.create_contextual_response(text, reason, confidence)
            
            if response:
                await self.speak(response)
                
        except Exception as e:
            self.logger.error(f"Erro na resposta cont√≠nua: {e}")
    
    async def create_contextual_response(self, text: str, reason: str, confidence: float) -> str:
        """Cria resposta baseada no contexto de detec√ß√£o"""
        try:
            user_info = self.user_profile.get_summary()
            emotions = self.context_analyzer.analyze_emotional_context(text)
            dominant_emotion = max(emotions, key=emotions.get)
            
            # Prompt adaptado ao contexto
            if "defesa" in reason.lower():
                context_prompt = f"""SITUA√á√ÉO: O usu√°rio fez um coment√°rio negativo sobre voc√™.
COMENT√ÅRIO: "{text}"
INSTRU√á√ÉO: Responda de forma educada mas se defendendo. Mostre que voc√™ √© √∫til e est√° aqui para ajudar."""
            
            elif "indireta" in reason.lower():
                context_prompt = f"""SITUA√á√ÉO: O usu√°rio mencionou voc√™ indiretamente em uma conversa.
COMENT√ÅRIO: "{text}"
INSTRU√á√ÉO: Responda de forma natural, como se estivesse participando da conversa."""
            
            elif confidence > 0.8:
                context_prompt = f"""SITUA√á√ÉO: O usu√°rio se dirigiu diretamente a voc√™.
PERGUNTA/COMANDO: "{text}"
INSTRU√á√ÉO: Responda de forma direta e √∫til."""
            
            else:
                context_prompt = f"""SITUA√á√ÉO: O usu√°rio pode estar falando com voc√™.
FALA: "{text}"
INSTRU√á√ÉO: Responda brevemente perguntando se era com voc√™ ou oferecendo ajuda."""
            
            prompt = f"""Voc√™ √© ARIA, uma assistente pessoal IA amig√°vel e inteligente.

INFORMA√á√ïES DO USU√ÅRIO:
{user_info}

EMO√á√ÉO DETECTADA: {dominant_emotion}

{context_prompt}

REGRAS:
- Seja natural e conversacional
- M√°ximo 2 frases
- Se for defesa, seja educada mas firme
- Use o nome do usu√°rio quando apropriado

RESPOSTA:"""
            
            response = await self.llm.generate_response(prompt)
            return response
            
        except Exception as e:
            self.logger.error(f"Erro ao criar resposta contextual: {e}")
            return "Desculpe, houve um erro interno."
    
    async def set_user_name(self, name: str):
        """Define nome do usu√°rio"""
        self.user_profile.user_info.name = name
        await self.user_profile.save_profile()
        response = f"Entendi! Agora sei que voc√™ se chama {name}."
        print(f"\\nü§ñ ARIA: {response}")
        await self.tts.speak(response)
    
    async def get_user_input(self) -> Optional[str]:
        """Obt√©m input de texto do usu√°rio"""
        try:
            print("\\nüí¨ Sua mensagem:")
            
            loop = asyncio.get_event_loop()
            user_text = await loop.run_in_executor(None, input, ">>> ")
            
            if user_text.strip():
                print(f"üë§ Voc√™: {user_text}")
                await self.conversation_manager.add_message("user", user_text)
                return user_text.strip()
                
        except Exception as e:
            self.logger.error(f"Erro ao obter input: {e}")
            return None
    
    async def listen_once(self) -> Optional[str]:
        """Escuta uma vez (modo manual)"""
        text = await self.stt.listen()
        if text:
            print(f"üë§ Voc√™ (voz): {text}")
            await self.conversation_manager.add_message("user", text)
        return text
    
    async def speak(self, text: str):
        """Fala o texto fornecido"""
        try:
            print(f"\\nü§ñ ARIA: {text}")
            await self.tts.speak(text)
            await self.conversation_manager.add_message("assistant", text)
        except Exception as e:
            self.logger.error(f"Erro na fala: {e}")
    
    async def process_input(self, user_input: str) -> Optional[str]:
        """Processa entrada normal do usu√°rio"""
        try:
            print("üß† Processando...")
            
            await self.user_profile.extract_and_update_info(user_input)
            
            prompt = self.create_simple_prompt(user_input)
            response = await self.llm.generate_response(prompt)
            
            return response
            
        except Exception as e:
            self.logger.error(f"Erro ao processar: {e}")
            return "Desculpe, houve um erro."
    
    def create_simple_prompt(self, user_input: str) -> str:
        """Cria prompt simples"""
        user_info = self.user_profile.get_summary()
        
        prompt = f"""Voc√™ √© ARIA, uma assistente pessoal amig√°vel.

USU√ÅRIO: {user_info}

PERGUNTA: {user_input}

Responda de forma natural e concisa (m√°ximo 2 frases).

RESPOSTA:"""
        
        return prompt
    
    def check_exit_command(self, text: str) -> bool:
        """Verifica comandos de sa√≠da"""
        exit_commands = ["sair", "tchau", "encerrar", "quit", "exit"]
        return any(cmd in text.lower() for cmd in exit_commands)
    
    async def shutdown(self):
        """Encerra o agente"""
        print("\\nüîÑ Encerrando...")
        self.is_running = False
        
        if self.continuous_mode:
            self.stop_continuous_mode()
        
        if self.user_profile:
            await self.user_profile.save_profile()
        
        if self.database:
            await self.database.close()
        
        print("üëã At√© logo!")
'''

# Salvar todos os arquivos
print("üìù Criando core/context_analyzer.py...")
with open("core/context_analyzer.py", "w", encoding="utf-8") as f:
    f.write(context_analyzer_code)

print("üìù Atualizando core/speech_to_text.py...")
with open("core/speech_to_text.py", "w", encoding="utf-8") as f:
    f.write(stt_code)

print("üìù Atualizando core/agent.py...")
with open("core/agent.py", "w", encoding="utf-8") as f:
    f.write(agent_code)

print("‚úÖ MODO CONT√çNUO CRIADO!")
print("")
print("üéØ FUNCIONALIDADES ADICIONADAS:")
print("‚Ä¢ üëÇ Escuta cont√≠nua em background")
print("‚Ä¢ üß† An√°lise inteligente de contexto")
print("‚Ä¢ üéØ Detec√ß√£o de men√ß√µes diretas/indiretas") 
print("‚Ä¢ üõ°Ô∏è Sistema de defesa quando falarem mal")
print("‚Ä¢ üí≠ An√°lise emocional do contexto")
print("‚Ä¢ üó£Ô∏è Respostas naturais baseadas na situa√ß√£o")
print("")
print("üöÄ Execute: python main.py")
print("üí° Teste: 'continuo' para ativar modo inteligente!")
print("üó®Ô∏è Exemplos:")
print("   - 'ARIA, que horas s√£o?' ‚Üí responde")
print("   - 'essa IA √© in√∫til' ‚Üí se defende")
print("   - 'como voc√™ est√°?' ‚Üí pergunta se √© com ela")